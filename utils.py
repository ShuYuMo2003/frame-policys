################ logging ########################
import sys
import logging
from genesis.styles import formats
from genesis.logging.logger import GenesisFormatter

class GeneralFormatter(GenesisFormatter):
    def __init__(self, verbose_time=True, logger_name="app"):
        super().__init__(verbose_time)

        self.logger_name = logger_name

    def colored_fmt(self, color):
        self.last_color = color
        return f"{color}[{self.logger_name}] [{self.TIME}] [{self.LEVEL}] {self.MESSAGE}{formats.RESET}"

def get_general_logger(logger_name="app", logging_level="DEBUG", verbose_time=False):
    logger = logging.getLogger(logger_name)
    logger.setLevel(logging_level)
    logger.propagate = False
    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(logging_level)
    handler.setFormatter(GeneralFormatter(verbose_time=verbose_time, logger_name=logger_name))
    logger.addHandler(handler)
    return logger
################ logging ########################



################ data type conversion ########################
import torch
import numpy as np
# ensure the return tensor is leaf-tensor.
def np2torch_clone(x):
    if isinstance(x, torch.Tensor):
        return x.detach().clone()
    elif isinstance(x, np.ndarray):
        x = x.copy()
        return torch.tensor(x)
    else:
        raise ValueError(f"Unsupported type: {type(x)}")
################ data type conversion ########################


################ geometry transformation ########################
from kornia.geometry.quaternion import quaternion_to_rotation_matrix as quat2mat
from kornia.geometry.quaternion import rotation_matrix_to_quaternion as mat2quat

def normalize_torch(v):
    return v / (torch.norm(v) + 1e-10)

# generated by chatgpt-5
def quat2omega(q, order='wxyz'):
    # q: (..., 4)  期望顺序为 w,x,y,z （若为 xyzw 会调换）
    if order == 'xyzw':
        x, y, z, w = q[..., 0], q[..., 1], q[..., 2], q[..., 3]
    elif order == 'wxyz':
        w, x, y, z = q[..., 0], q[..., 1], q[..., 2], q[..., 3]
    else:
        raise ValueError("quat_order must be 'wxyz' or 'xyzw'.")

    # Ω(q)（4×3）满足 qdot = 0.5 * Ω(q) * ω
    # 这里的四元数采用 [w, x, y, z] 约定来写矩阵；若传入的是 xyzw 已在上面换位
    # Ω = [[-x, -y, -z],
    #      [ w, -z,  y],
    #      [ z,  w, -x],
    #      [-y,  x,  w]]
    row0 = torch.stack([-x, -y, -z], dim=-1)
    row1 = torch.stack([ w, -z,  y], dim=-1)
    row2 = torch.stack([ z,  w, -x], dim=-1)
    row3 = torch.stack([-y,  x,  w], dim=-1)
    return torch.stack([row0, row1, row2, row3], dim=-2)  # (..., 4, 3)

def quat_mul(q2: torch.Tensor, q1: torch.Tensor, normalize: bool = False, eps: float = 1e-10) -> torch.Tensor:
    # 解包 (w, x, y, z)
    w1, x1, y1, z1 = q1.unbind(dim=-1)
    w2, x2, y2, z2 = q2.unbind(dim=-1)

    # 依据 (a2,b2)*(a1,b1) = (a2 a1 - b2·b1, a2 b1 + a1 b2 + b2×b1)
    w = w2*w1 - x2*x1 - y2*y1 - z2*z1
    x = w2*x1 + w1*x2 + y2*z1 - z2*y1
    y = w2*y1 + w1*y2 + z2*x1 - x2*z1
    z = w2*z1 + w1*z2 + x2*y1 - y2*x1

    q = torch.stack((w, x, y, z), dim=-1)

    if normalize:
        q = q / q.norm(dim=-1, keepdim=True).clamp_min(eps)
        # 如需将实部统一到非负半球，可启用下面两行：
        sign = torch.where(q[..., 0:1] < 0, -1.0, 1.0)
        q = q * sign

    return q
################ geometry transformation ########################


################ debug ########################
def make_tensor_hook(name):
    def hook(grad):
        if grad is None:
            return
        if torch.isnan(grad).any() or torch.isinf(grad).any():
            msg = (f"[{name}] grad is Nan"
                    f"grad_abs_max={grad.abs().max().item():.3e} "
                    f"shape={tuple(grad.shape)}")
            print(msg)
        else:
            print(f"[{name}] grad is ok")
    return hook
################ debug ########################



################ visualization ########################
import matplotlib.pyplot as plt
import scienceplots
from typing import List
from PIL import Image

def draw_curve_line(x, name: str, xlabel: str="X", ylabel: str="Y") -> np.ndarray:
    save_curve_line(x, name, save_path=f"/tmp/{name}.png", xlabel=xlabel, ylabel=ylabel)
    return np.array(Image.open(f"/tmp/{name}.png"))

def save_curve_line(x, name: str, save_path: str=None, xlabel: str="X", ylabel: str="Y"):
    if save_path is None: save_path = f"{name}.png"

    # plt.style.use('science')
    fig, ax = plt.subplots(figsize=((6.4, 4.8)))
    ax.plot(x)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.set_title(name)
    fig.savefig(save_path)
    plt.close()

def make_frame_func(imgs: List[np.ndarray]):
    def frame_func(t):
        return imgs[int(t)]
    return frame_func
################ visualization ########################